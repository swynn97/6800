AS02 Assembler for M6802 [1.42].                                     Page    1
------------------------------ TBUG_retro68.asm ------------------------------

1224 lines read, no errors in pass 1.
                        		title "tbug"
                        ;
                        ; Complete source to Newbear TBUG, hand-typed in
                        ;
                        ; Revision histoy:
                        ; 	1.0	Initial version
                        ;	2.0	Version for Retro68 project
                        ;	2.1	2/16/25 - Removed VDU drivers, changed 'U' to 'Z
                        ;	2.2	2/24/25 - Removed remaining VDU mem and code, st
                        ;			  PIAB code removed, moved up remaining TBUG scrat
                        ;			  vs. A080H	
                        ;	2.3	3/15/25	- Moved TBUG specific scratchpad back to
                        ;			  with the stack for loaded program such as BASIC 
                        ;			  code.			  			
                        ;	2.4	3/15/25 - Added code to fix RUBIG and WAIT issue
                        ;	2.5	3/21/25	- Added back 'U' command, added TSC Micr
                        ;	2.6	3/25/25	- Removed U command and replaced this wi
                        ;			  lcd_driver blocks interrupts when talking to PIA
                        ;			  Added virual PIA port and cleaned up INCH code t
                        ;			  we no longer need. This is last version on a 16x
                        ;
                        ; Note: Spare space labbeled with 'SPARE SPACE'
                        ;
                        ; TEMP Notes area:
                        ;
                        ; - Tagged all the NOPs as SPARE SPACE
                        ; - Removed all PIA B references for now - commented o
                        ; 
                        ;
                        ;***************************************************
                        ; This macro is used to verify that the current
                        ; address meets a required value.  Used mostly to
                        ; guarantee changes don't cause entry points to
                        ; move.  These are used right before documented
                        ; entry points.
                        ;
                        VERIFY          macro   expected
                                        if * != expected
                                        fail    Not at requested address (expe
                                        endif
                                        endm
                        ;
0000 =                  false           equ     0
ffff =                  true            equ     ~false
                        
                        ; Options
                        ;
ffff =                  BASIC	equ	true	;include TSC MicroBasic image and loade
                        ;
                                        bss
a000 =                                  org     $A000
                        ;
002e =                  STACK_SIZE      equ     46	;as per orig TBUG source, n
                        ;
                        ;LCD display size
                        ;
0010 =                  LCDWIDTH       equ     16
0002 =                  LCDROWS        equ     2
0020 =                  LCDBUFSZ       equ     LCDWIDTH*LCDROWS        ;size o
                        ;
                        ; Scratchpad RAM - xTBUG version to maintain compatibi
AS02 Assembler for M6802 [1.42].                                     Page    2
------------------------------------ tbug ------------------------------------

                        ;
a000 =                  IRV             ds      2       ;IRQ POINTER
a002 =                  BEGA            ds      2       ;BEGINNING ADDR PNCH
a004 =                  ENDA            ds      2       ;ENDING ADDR PNCH
a006 =                  NMV             ds      2       ;NMI INTERRUPT VECTOR
a008 =                  SP              ds      1       ;S HIGH
a009 =                                  ds      1       ;S LOW
a00a =                  CKSM            ds      1       ;CHECKSUM
a00b =                  BYTECT          ds      1       ;BYTECT AND MCONT TEMP
a00c =                  XHI             ds      1       ;XREG HIGH
a00d =                  XLOW            ds      1       ;XREG LOW
a00e =                  TEMP            ds      1       ;TEMPORARY STORAGE
a00f =                  TW              ds      2       ;TEMPORARY STORAGE
a011 =                  MCONT           ds      1       ;Frame count
a012 =                  XTEMP           ds      2       ;X-REG TEMP STGE
a014 =                                  ds      STACK_SIZE
a042 =                  STACK           ds      1       ;SWTBUG STACK
a043 =                  STACIN		ds	5	;RTI Stack (orig TBUG source has this as 
                        ;
                        ; Note: The locations A048 and A049 contain the addres
                        ; the RTI instruction jumps.  It's often loaded with t
                        ; address of a program just loaded from tape so the "G
                        ; command will execute it.
                        ;
                                        VERIFY  $a048
                        
a048 =                  RTIVEC          ds      2	;As per orig TBUG, length of
                        ;
a080 =                  		org	$A080
                        ;
a080 =                  VPIAPR          ds    	1	;Virtual PIA input port - dat
a081 =                  VPIACN          ds   	1 	;Virtual PIA input port - con
a082 =                  NAME            ds      11	;Additionsl TBUG storage. 
a08d =                  CAPSLK          ds      1	;When high, force caps lock	
a08e =                  WAIT            ds      1 	
                        ;
                        ; LCD ram storage
                        ;
a08f =                  lcd_row                ds      1               ;Curren
a090 =                  lcd_col                ds      1               ;Curren
a091 =                  lcd_buf                ds      LCDBUFSZ        ;backin
a0b1 =                  lcd_tempx      ds      2                       ;tenp s
a0b3 =                  lcd_buf_addr   ds      2                       ;used t
a0b5 =                  lcd_charx      ds      3                       ;temp s
                        ;
                        ;
                        ;***************************************************
                        ; Common ASCII codes
                        ;
0004 =                  EOT             equ     $04
0007 =                  BEL             equ     $07
0008 =                  BS              equ     $08
000a =                  LF              equ     $0a
000d =                  CR              equ     $0d
007f =                  DEL             equ     $7f
000c =                  FF              equ     $0c
0020 =                  SPACE		equ	$20
0000 =                  NULL		equ	$0
007f =                  RUB		equ	$7f
005e =                  CARET		equ	$5e
                        ;
                        ;***************************************************
AS02 Assembler for M6802 [1.42].                                     Page    3
------------------------------------ tbug ------------------------------------

                        ; I/O base address and SWTPC type slot numbers.
                        ; These constants are used by each module that uses I/
                        ; to calculate actual addresses. This gets a little me
                        ; in the actual modules, but any I/O address changes s
                        ; only be done today.
                        ;
8000 =                  IOBASE          equ     $8000
0004 =                  IOBYTES         equ     4
                        ;
                        ; Slot used by console ACIA
0000 =                  CONSLOT         equ     0
                        ;
                        ; KB/Paper tape slot PIA used by TBUG
0004 =                  KBSLOT          equ     4
                        ;
                        ;***************************************************
                        ;
                        ; This section should end at A090H
                        ;
                        ; Start of Code!
                        ; Copied from OCR. Opcodes and comments should be lowe
                        ; Labels should all be kept as upper case to maintain
                        ; compatibility with xtbug code
                        ;
8000 =                  ACIACN 		equ   	IOBASE+(IOBYTES*CONSLOT)
8001 =                  ACIADT 		equ   	IOBASE+(IOBYTES*CONSLOT)+1
8010 =                  PIAAPR 		equ   	IOBASE+(IOBYTES*KBSLOT)
8011 =                  PIAACN 		equ   	IOBASE+(IOBYTES*KBSLOT)+1
8012 =                  PIABPR 		equ   	IOBASE+(IOBYTES*KBSLOT)+2
8013 =                  PIABCN 		equ   	IOBASE+(IOBYTES*KBSLOT)+3
0000 =                  YCIACN 		equ   	IOBYTES*CONSLOT
0001 =                  YCIADT 		equ   	IOBYTES*CONSLOT+1
0010 =                  XIAAPR 		equ   	(IOBYTES*KBSLOT)
0011 =                  XIAACN 		equ   	(IOBYTES*KBSLOT)+1
0012 =                  XIABPR 		equ   	(IOBYTES*KBSLOT)+2
0013 =                  XIABCN 		equ   	(IOBYTES*KBSLOT)+3
                        ;
0001 =                  XLOWX		equ	XLOW-XHI
0003 =                  TWX		equ	TW-XHI
0000 =                  XHIX		equ	XHI-XHI
                        ;
                        ;XISAD		equ	DISAD-DISAD
                        ;KOLPTR		equ	COLPTR-DISAD
                        ;XOWPTR		equ	ROWPTR-DISAD
                        ;KHARST		equ	CHARST-DISAD
                        ;
                        ;
                        		code
e000 =                  		org	$e000
                        ;
                        		VERIFY	$e000
                        
                        ;
                        ; Interrupt vectors
                        ;
e000 : fea000           IRQ 	ldx    	IRV    		;irq vector from scratchpad
e003 : 6e00                   	jmp    	0,x    		;and jump to where it points
e005 : fea006           NMI 	ldx    	NMV    		;get nmi vector
e008 : 6e00                   	jmp    	0,x    		;and jump
                        ;
                        ; S1 Load 'L'
                        ;
AS02 Assembler for M6802 [1.42].                                     Page    4
------------------------------------ tbug ------------------------------------

e00a : 2007             LOAD 	bra	LOAD3	
e00c : 7da08e           QWAIT 	tst  	WAIT   		;if wait then loop forever
e00f : 27fe             WTLOOP 	beq   	WTLOOP 		;exit is achieved by reset
e011 : 2031                   	bra    	C1
e013 : 8d63             LOAD3 	bsr    	INCHBR   		;get char look for 's1' (sta
e015 : 8153                   	cmpa 	#'S'    	;of block) or 's9' end of file
e017 : 26fa                   	bne    	LOAD3  		;not 's so look again
e019 : 8d5d                   	bsr    	INCHBR
e01b : 8139                   	cmpa 	#'9'
e01d : 27ed                   	beq    	QWAIT  		;branch if end of file (s9)
e01f : 8131                   	cmpa 	#'1'
e021 : 26f0                   	bne    	LOAD3  		;if 's1' or 's9' not found
e023 : 7fa00a               	clr    	CKSM   		;'s1' found begin load
e026 : 8d2d                   	bsr    	BYTE   		;get byte count
e028 : 8002                   	suba 	#02
e02a : b7a00b               	staa 	BYTECT
e02d : 8d18                   	bsr    	BADDR  		;get address of block
e02f : 8d24             LOAD11 	bsr   	BYTE  		;get data
e031 : 7aa00b               	dec    	BYTECT
e034 : 2705                   	beq    	LOAD15
e036 : a700                   	staa 	0,x
e038 : 08                       inx
e039 : 20f4                   	bra    	LOAD11
e03b : 7ca00a           LOAD15 	inc 	CKSM
e03e : 27d3                   	beq    	LOAD3  		;checksum o.k.
e040 : 863f             LOAD19 	ldaa 	#'?'   		;error so print question mark
e042 : 8d31                   	bsr    	OUTCHBR
e044 : 7ee0e3           C1  	jmp    	CONTRL
                        ;
                        	VERIFY	$e047
                        
                        ;
e047 : 8d0c             BADDR 	bsr    	BYTE   		;get 1st. byte of address
e049 : b7a00c               	staa 	XHI
e04c : 8d07                   	bsr   	BYTE    	;get 2nd. byte
e04e : b7a00d               	staa 	XLOW
e051 : fea00c               	ldx   	XHI     	;x=address
e054 : 39                       rts
                        ;
                        ; Get hex byte
                        ;
                        	VERIFY	$e055
                        
                        ;
e055 : 8d53             BYTE 	bsr    	INHEX  		;get 1st. hex char (most sig.)
e057 : 48                       asla         		;shift left 4 times
e058 : 48                       asla
e059 : 48                       asla
e05a : 48                       asla
e05b : 16                       tab           		;save in b
e05c : 8d4c                   	bsr   	INHEX   	;get 2nd. hex char.
e05e : 1b                       aba           		;add accumulators to form byte
e05f : 16                       tab
e060 : fba00a               	addb 	CKSM   		;add this byte to checksum
e063 : f7a00a               	stab 	CKSM
e066 : 39                       rts
                        ;
                        	VERIFY	$e067
                        
                        ;
e067 : 44               OUTHL 	lsra
e068 : 44                       lsra
AS02 Assembler for M6802 [1.42].                                     Page    5
------------------------------------ tbug ------------------------------------

e069 : 44                       lsra
e06a : 44                       lsra
                        ;
                        	VERIFY	$e06b
                        
                        ;
e06b : 840f             OUTHR 	anda 	#$0f
e06d : 8b30                   	adda 	#$30   		;convert hex to ascii
e06f : 8139                   	cmpa 	#$39
e071 : 2302                   	bls  	OUTCHBR
e073 : 8b07                   	adda 	#07
e075 : 7ee1d1           OUTCHBR	jmp 	OUTCH		;modified from original TBUG, OUTE
e078 : 7ee1ac           INCHBR 	jmp  	INCH		;..and also for INCH, so INPOLL->I
e07b : 8df8             PDT2 	bsr    	OUTCHBR
e07d : 08                       inx
                        ;
                        ; Output text string pointed to by x
                        ;
                        	VERIFY	$e07e
                        
                        ;
e07e : a600             PDATA 	ldaa 	0,x    		;output area of memory as text
e080 : 8104                   	cmpa 	#04    		;until eot(04) is found
e082 : 26f7                   	bne   	PDT2
e084 : 39                       rts
                        ;
                        ; Change memory command 'M'
                        ;
e085 : 8dc0             CHANGE 	bsr	BADDR  		;memory inspect/modify command
e087 : cee19b           CHA51 	ldx 	#MCL
e08a : 8df2                   	bsr   	PDATA  		;get address
e08c : cea00c               	ldx   	#XHI
e08f : 8d37                  	bsr   	OUT4HS 		;print address
e091 : fea00c               	ldx   	XHI
e094 : 8d34                  	bsr   	OUT2HS 		;print contents of this
e096 : ffa00c               	stx   	XHI    		;location
e099 : 8ddd                   	bsr   	INCHBR
e09b : 8120                   	cmpa 	#$20
e09d : 26e8                   	bne   	CHA51  		;if not sp then try next loc
e09f : 8db4                   	bsr   	BYTE   		;get new data for this loc
e0a1 : 09                       dex
e0a2 : a700                   	staa 	0,x    		;and store
e0a4 : a100                   	cmpa 	0,x    		;did it store?
e0a6 : 27df                   	beq   	CHA51  		;if it did then look at next
e0a8 : 2096                   	bra   	LOAD19 		;memory fault print '?'
e0aa : 8dcc             INHEX 	bsr   	INCHBR
e0ac : 8030                   	suba 	#$30   		;convert ascii to hex
e0ae : 2b94                   	bmi   	C1     		;- to 'C1' if not hex
e0b0 : 8109                  	cmpa 	#$09
e0b2 : 2f0a                   	ble    	HGRET
e0b4 : 8111                   	cmpa 	#$11
e0b6 : 2b8c                   	bmi    	C1
e0b8 : 8116                   	cmpa 	#$16
e0ba : 2e88                   	bgt    	C1
e0bc : 8007                   	suba 	#$07
e0be : 39               HGRET 	rts
                        ;
                        	VERIFY	$e0bf
                        
                        ;
e0bf : a600             OUT2H 	ldaa 	0,x		;output 2 hex chars
e0c1 : 8da4             OUT2HA 	bsr   	OUTHL  		;output left hex char.
AS02 Assembler for M6802 [1.42].                                     Page    6
------------------------------------ tbug ------------------------------------

e0c3 : a600                   	ldaa 	0,x
e0c5 : 08                       inx
e0c6 : 20a3                   	bra    	OUTHR   	;output right hex char return.
                        ;
                        	VERIFY	$e0c8
                        
                        ;
e0c8 : 8df5             OUT4HS 	bsr   	OUT2H   	;output 4 hex + space
                        ;
                        	VERIFY	$e0ca
                        
                        ;
e0ca : 8df3             OUT2HS 	bsr   	OUT2H   	;output 2 hex + space
                        ;
                        	VERIFY	$e0cc
                        
                        ;
e0cc : 8620             OUTS  	ldaa 	#$20    	;output a space
e0ce : 20a5                   	bra    	OUTCHBR
e0d0 : 8ea042           START 	lds  	#STACK  	;init stack pointer. Changed fro
e0d3 : bfa008               	sts    	SP
e0d6 : 8603                   	ldaa 	#03     	;reset acia
e0d8 : b78000               	staa 	ACIACN
e0db : 4c                       inca
e0dc : b78011               	staa 	PIAACN  	;init pia(a)
e0df : bde2a3               	jsr    	INIT    	;'init' continues initialising
e0e2 : 01                       nop            		;the system
e0e3 : 8ea042           CONTRL 	lds 	#STACK		;Changed from hard coded value in
e0e6 : cee19b               	ldx    	#MCL    	;print asterisk
e0e9 : 8d93                   	bsr    	PDATA
e0eb : 8d8b                   	bsr    	INCHBR    	;get command
e0ed : 16                       tab
e0ee : 8ddc                   	bsr    	OUTS    	;output a space
e0f0 : cee3d3               	ldx    	#TABLE
e0f3 : 6d00             SCAN  	tst    	0,x     	;end of table?
e0f5 : 270d                   	beq    	NOCOMM
e0f7 : e100                   	cmpb 	0,x    		;does command match?
e0f9 : 2604                   	bne    	INCT    	;if not then branch
e0fb : ee01                   	ldx    	1,x     	;get command address
e0fd : 6e00                   	jmp    	0,x     	;and jump to it
e0ff : 08               INCT  	inx            		;x+1 to point at the next
e100 : 08                       inx            		;command char.
e101 : 08                       inx
e102 : 20ef                   	bra    	SCAN
                        ;
e104 : 7ee040           NOCOMM 	jmp 	LOAD19
                        ;
                        ; Toggle caps lock function
                        ;
e107 : 73a08d           TGLCAP	com	CAPSLK		;just toggle the caps lock flag
e10a : 20d7               	bra    	CONTRL 		;then return
                        ;	
e10c : 01                       nop
e10d : 01                       nop
e10e : 01                       nop
                        ;
                        ; Go 'G' command
                        ;
e10f : bea008           GO  	lds    	SP		;restore stack pointer
e112 : 3b                       rti            		;and load internal regs and g
e113 : bfa008           SFE 	sts    	SP		;save stack pointer
e116 : 30                       tsx
AS02 Assembler for M6802 [1.42].                                     Page    7
------------------------------------ tbug ------------------------------------

e117 : 6d06                   	tst    	6,x     	;decrement program counter now
e119 : 2602                   	bne    	NDEC    	;on stack
e11b : 6a05                     dec    	5,x
e11d : 6a06             NDEC  	dec    	6,x
                        ;
                        ; Register dumo 'R' command
                        ;
e11f : fea008           PRINT 	ldx    	SP      	;print contents of stack
e122 : 08                       inx
e123 : 8da5                     bsr    	OUT2HS
e125 : 8da3                     bsr    	OUT2HS
e127 : 8da1                     bsr    	OUT2HS
e129 : 8d9d                     bsr    	OUT4HS
e12b : 8d9b                     bsr    	OUT4HS
e12d : cea008                 	ldx    	#SP
e130 : 8d96                     bsr    	OUT4HS
e132 : 20af             C2      bra    	CONTRL
                        ;
e134 : 0d0a0000000053.. MTAPE 	db     CR,LF,0,0,0,0,"S1",EOT
                        ;
                        ; Punch 'P' command
                        ;
e13d : bde299           PUNCH 	jsr    	AUTO    	;- settle auto recording level
e140 : fea002           NAUTP 	ldx    	BEGA
e143 : ffa00f                 	stx    	TW      	;- put start address in temp
e146 : b6a005           PUN11 	ldaa 	ENDA+1
e149 : b0a010                 	suba 	TW+1
e14c : f6a004                 	ldab 	ENDA
e14f : f2a00f                 	sbcb 	TW
e152 : 2604                     bne    	PUN22
e154 : 8110                     cmpa 	#16
e156 : 2502                     bcs    	PUN23
e158 : 860f             PUN22 	ldaa 	#15
e15a : 8b04             PUN23 	adda 	#4
e15c : b7a011                 	staa 	MCONT   	;frame count of this record
e15f : 8003                     suba 	#3
e161 : b7a00e                 	staa 	TEMP    	;byte count of this record
e164 : cee134                 	ldx    	#MTAPE
e167 : bde07e                 	jsr    	PDATA
e16a : 5f               	clrb			;clear checksum
e16b : cea011                 	ldx    	#MCONT
e16e : 8d26                    	bsr    	PUNT2   	;output frame count
e170 : cea00f                 	ldx    	#TW
e173 : 8d21                     bsr    	PUNT2   	;output start address of this
e175 : 8d1f                     bsr    	PUNT2
e177 : fea00f                 	ldx    	TW
e17a : 8d1a             PUN32 	bsr     PUNT2
e17c : 7aa00e                 	dec    	TEMP
e17f : 26f9                     bne    	PUN32   	;output a byte
e181 : ffa00f                 	stx    	TW
e184 : 53                       comb
e185 : 37                       pshb
e186 : 30                       tsx
e187 : 8d0d                     bsr    	PUNT2 		;output checksum
e189 : 33                       pulb
e18a : fea00f               	ldx   	TW
e18d : 09                       dex
e18e : bca004               	cpx   	ENDA
e191 : 26b3                   	bne   	PUN11
e193 : 7ee2c5               	jmp   	S9OUT   	;output 's9' and return
e196 : eb00             PUNT2 	addb 	0,x     	;output 2 hex chars and update
e198 : 7ee0bf               	jmp   	OUT2H
AS02 Assembler for M6802 [1.42].                                     Page    8
------------------------------------ tbug ------------------------------------

                        ;
e19b : 0d0a00002a04     MCL   	db	CR,LF,0,0,'*',EOT
                        ;
                        ; Jump 'J' command
                        ;
e1a1 : 8d49             JUMP  	bsr   	BADLK   	;get address from user
e1a3 : 6e00                   	jmp   	0,x    		;and jump to it
e1a5 : ffa012           SAVX	stx   	XTEMP   	;store x
                        ;
e1a8 : ce8000               	ldx   	#IOBASE  	;point x at to IO base
e1ab : 39                       rts
                        ;
                        	VERIFY	$e1ac
                        
                        ;
e1ac : 867f             INCH	ldaa 	#$7f    	;input one char from port into, ch
                        ;
                        	VERIFY	$e1ae
                        
                        ;
e1ae : 8df5             INXBIT 	bsr  	SAVX    	;put '7f' ignore m.s. bit
e1b0 : 37                       pshb         		;save b
                        ;
                        ; The original PIA port B has been removed, OG code in
                        ; Introduces concept of a virtual port that can be wrr
                        ; and interrupt routine.
                        ;
                        ;POLL1 	;ldab 	XIABCN,x  	;does pia(b) have something 
                              	;bpl   	POLL2
                              	;anda 	XIABPR,x  	;get data from pia(b)
                              	;bra   	RET
e1b1 : f6a081           POLL1	ldab	VPIACN		;see if anything has been written t
e1b4 : 2708             	beq	POLL2	
e1b6 : b4a080           	anda	VPIAPR		;if it has, read the port value and clea
e1b9 : 7fa081           	clr	VPIACN		;since this is not a real PIA...
e1bc : 2031             	bra	CCAPSLK		
                        ;
e1be : e611             POLL2 	ldab 	XIAACN,x  	;does pia(a) have something
e1c0 : 2a04                   	bpl   	POLL3
e1c2 : a410                   	anda 	XIAAPR,x  	;get data from pia(a)
e1c4 : 2029                   	bra   	CCAPSLK		
e1c6 : e600             POLL3 	ldab 	YCIACN,x  	;does acia have something?
e1c8 : 54                       lsrb
e1c9 : 24e6                   	bcc   	POLL1
e1cb : a401                   	anda 	YCIADT,x  	;get data from acia
e1cd : 2020             	bra	CCAPSLK
                        ;
e1d1 =                  		org	$e1d1
                        ;
                        ; OUTCH routine
                        ;
                        	VERIFY	$e1d1
                        
                        ;
e1d1 : 2004             OUTCH  	bra   	OUTP    	;Mess of branches so output ro
e1d3 : 33               DIG   	pulb
e1d4 : fea012               	ldx   	XTEMP
e1d7 : 8dcc             OUTP  	bsr   	SAVX
e1d9 : 37                       pshb
e1da : f68000           NOTRDY 	ldab 	ACIACN 		;acia ready to transmit?
e1dd : 54                       lsrb
e1de : 54                       lsrb
AS02 Assembler for M6802 [1.42].                                     Page    9
------------------------------------ tbug ------------------------------------

e1df : 24f9             F9      bcc   	NOTRDY 		;no
e1e1 : b78001                	staa 	ACIADT 		;pass char to acia for transmit
e1e4 : bde408           	jsr	lcd_outch	;Call lcd_outch to display on LCD displ
e1e7 : 33               	pulb
e1e8 : fea012           	ldx   	XTEMP   	;restore x
e1eb : 39                       rts
                        ;
e1ec : 7ee047           BADLK 	jmp 	BADDR
                        ;
                        ;
                        ; Force caps lock if flag set - TBUG and most apps onl
                        ;
e1ef : 7da08d           CCAPSLK	tst	CAPSLK		;test if caps lock enabled
e1f2 : 27df             	beq	DIG
e1f4 : 8161             	cmpa	#'a'		;if less that 'a' do nothing
e1f6 : 2ddb             	blt	DIG			
e1f8 : 817a             	cmpa	#'z'		;if greater than 'z' do nothing
e1fa : 2ed7             	bgt	DIG	
e1fc : 84df             	anda	#$df		;otherwise, force upper case
e1fe : 20d3             	bra	DIG	
                        ;
                        ; SPARE SPACE
                        ;
e299 =                  		org	$e299
                        ;
e299 : c620             AUTO    ldab    #$20            ;output 32 nulls
e29b : 4f                       clra                    ;to allow auto recordi
e29c : bde1d1           NULOUT  jsr     OUTCH           ;level to settle
e29f : 5a                       decb
e2a0 : 26fa                     bne     NULOUT
e2a2 : 39                       rts
e2a3 : 8615             INIT 	ldaa 	#$15    	;init acia-one stop bit and
e2a5 : b78000                	staa 	ACIACN  	;8 bits of data no parity
                        ;
e2a8 : 8601             	lda     #$01            ;set the WAIT bit to always r
e2aa : b7a08e                   staa    WAIT            ;Initialize the WAIT v
e2ad : 7fa08d                   clr    	CAPSLK		;Clear caps lock flag
                        ;
e2b0 : 7fa081           	clr	VPIACN		;clear virtaul PIA port control 'reg'
e2b3 : bde4f0           	jsr	piab_init	;Initialize the PIA for the LCD display
                        ;
e2b6 : bde502           	jsr	lcd_init	;Initialize the LCD display
e2b9 : cee3fe                	ldx   	#TBSTR  	;print 'tbug'
e2bc : bde07e                	jsr   	PDATA
                        ;
e2bf : 39               	rts
e2c0 : 01               	nop			;SPARE SPACE
e2c1 : 01               	nop			;SPARE SPACE
e2c2 : 01               	nop			;SPARE SPACE
e2c3 : 01               	nop			;SPARE SPACE
e2c4 : 01               	nop			;SPARE SPACE
                        ;
e2c5 : cee3a1           S9OUT 	ldx  	#S9STR  	;-output 's9'
e2c8 : bde07e                	jsr   	PDATA
e2cb : 2042                    	bra   	C4
                        ;
                        ; Copy 'Y' command
                        ;
e2cd : 8d46             COPY 	bsr     BDSP    	;copy a block of memory-get
e2cf : ffa082                	stx   	NAME    	;start of block address
e2d2 : 8d41                    	bsr   	BDSP    	;get end address of block
e2d4 : 08                       inx           		;increment it
AS02 Assembler for M6802 [1.42].                                     Page   10
------------------------------------ tbug ------------------------------------

e2d5 : ffa00f                	stx   	TW      	;and store
e2d8 : 8d3b                   	bsr   	BDSP    	;get start address of start
e2da : fea082                	ldx   	NAME    	;od destination block
e2dd : a600             MOVEIT 	ldaa 	0,x     	;move move move!
e2df : fea00c                	ldx   	XHI
e2e2 : a700                    	staa 	0,x
e2e4 : 08                       inx
e2e5 : ffa00c                	stx   	XHI
e2e8 : fea082                	ldx   	NAME
e2eb : 08                       inx
e2ec : ffa082                	stx   	NAME
e2ef : bca00f                	cpx   	TW      	;end?
e2f2 : 26e9                    	bne   	MOVEIT
e2f4 : 2019                    	bra   	C4
                        ;
                        ; Block tabulate 'K'
                        ; 
e2f6 : 8d1d             BLKTAB 	bsr   	BDSP    	;tabulate block of 64 bytes
e2f8 : c640                    	ldab 	#$40    	;get address of start of block
e2fa : cee394                	ldx   	#CRS
e2fd : bde07e                	jsr   	PDATA   	;output carriage return etc.
e300 : fea00c                	ldx   	XHI
e303 : bde0bf           TAB2 	jsr   	OUT2H   	;output 2 hex chars (one byte)
e306 : 8d0a                    	bsr   	OUTSLK  	;and 3 spaces
e308 : 8d08                    	bsr   	OUTSLK
e30a : 8d06                    	bsr   	OUTSLK
e30c : 5a                       decb         		;finished?
e30d : 26f4                    	bne   	TAB2
e30f : 7ee0e3           C4   	jmp   	CONTRL
e312 : 7ee0cc           OUTSLK 	jmp 	OUTS
                        ;
                        	VERIFY	$e315
                        
                        ;
e315 : bde047           BDSP 	jsr   	BADDR   	;build address and output
e318 : 8df8                    	bsr   	OUTSLK  	;a space
e31a : 39                       rts
e31b : 7ee1d1           OUTLNK 	jmp 	OUTCH
e31e : c60c             TEXSTR 	ldab 	#$0c     	;input up to ten chars
e320 : cea082               	ldx   	#NAME   	;and terminate with eot
e323 : 5a               NFIN 	decb           		
e324 : 2603                    	bne   	NERR
e326 : 7ee040                	jmp   	LOAD19  	;too many chars! so exit
e329 : bde1ac           NERR 	jsr   	INCH
e32c : 810d                    	cmpa 	#CR     	;carriage return(end of string
e32e : 2705                    	beq   	ENDSTR
e330 : a700                   	staa 	0,x     	;store char
e332 : 08                       inx
e333 : 20ee                   	bra   	NFIN
e335 : 860a             ENDSTR 	ldaa 	#LF	    	;output line feed
e337 : 8de2                   	bsr   	OUTLNK
e339 : 8604                   	ldaa 	#$04     	;terminate string
e33b : a700                   	staa 	0,x
e33d : 39                       rts
                        ;
                        ; Save 'V' command
                        ;
e33e : 8dde             SAVE  	bsr   	TEXSTR
e340 : bde299               	jsr   	AUTO
e343 : 4c                       inca         		;soh (start of header)
e344 : 8dd5                   	bsr   	OUTLNK  	;output it 4 times to mark the
e346 : 8dd3                   	bsr   	OUTLNK  	;beginning of a header
AS02 Assembler for M6802 [1.42].                                     Page   11
------------------------------------ tbug ------------------------------------

e348 : 8dd1                   	bsr   	OUTLNK
e34a : 8dcf                   	bsr   	OUTLNK
e34c : cea082               	ldx   	#NAME   	;output name of file
e34f : bde07e               	jsr   	PDATA
e352 : 7ee140               	jmp   	NAUTP   	;output it in 's1' format
                        ;
                        ; Input names file 'I' command
                        ;
e355 : 8dc7             INFILE 	bsr  	TEXSTR  	;get name of file which we are
e357 : c604             NOMAT 	ldab 	#$04     	;looking for
e359 : 8d3c             N4IN 	bsr    	INCASS  	;accept input from serial
e35b : 8101                   	cmpa 	#$01     	;port onle (cassette)
e35d : 2712                   	beq   	HDFN    	;'soh' char found? branch if
e35f : 8153                   	cmpa 	#'S'     	;so end of file (s9)?
e361 : 26f4                   	bne   	NOMAT   	;if neither of these then look
e363 : 8d32                  	bsr   	INCASS  	;again
e365 : 8139                   	cmpa 	#'9'     	;is9t
e367 : 26ee                   	bne   	NOMAT   	;branch if not
e369 : cee391               	ldx   	#ENDST  	;say that we've found the end
e36c : bde07e               	jsr   	PDATA   	;one of his files
e36f : 20e6                   	bra   	NOMAT   	;and look again
e371 : 5a               HDFN 	decb
e372 : 26e5                   	bne   	N4IN    	;4 'soh' chars found no branch
e374 : cea082               	ldx   	#NAME   	;point x to name searched for
e377 : bde1ac           CHREQ 	jsr 	INCH  	;get char of name comming in
e37a : a100                   	cmpa 	0,x     	;do they match?
e37c : 2709                   	beq   	NAMSM   	;if so then branch
e37e : bde1ac           INNAM 	jsr 	INCH  	;dont match but print name
e381 : 810a                   	cmpa 	#LF     	;of file we've found anyway
e383 : 26f9                   	bne   	INNAM
e385 : 20d0                   	bra   	NOMAT   	;and look again
e387 : 08               NAMSM 	inx
e388 : 8604                   	ldaa 	#$04
e38a : a100                   	cmpa 	0,x     	;end of name?
e38c : 26e9                   	bne   	CHREQ   	;branch if not
e38e : 7ee00a               	jmp   	LOAD    	;load file
                        ; 
e391 : 454e44           ENDST 	db  	"END"
                        ;
e394 : 0d0a04           CRS	db	CR,LF,EOT
                        ;
e397 : b68000           INCASS 	ldaa 	ACIACN 		;input from serial port only
e39a : 44                       lsra
e39b : 24fa                   	bcc   	INCASS
e39d : b68001               	ldaa 	ACIADT
e3a0 : 39                       rts
                        ;
e3a1 : 20533904         S9STR 	db	" S9",EOT
                        ;
                        ; Branch calculator 'T' command
                        ;
e3a5 : bde315           BCALC 	jsr 	BDSP   		;calculate branch offset-
e3a8 : 08                       inx         		; increment it twice
e3a9 : 08                       inx
e3aa : ffa00f               	stx   	TW     		;and store
e3ad : bde315               	jsr   	BDSP    	;get destination address
e3b0 : cea00c               	ldx   	#XHI
e3b3 : e601                   	ldab 	XLOWX,x 	;check for out of range
e3b5 : e004                   	subb 	TWX+1,x
e3b7 : a600                   	ldaa 	XHIX,x
e3b9 : a203                   	sbca 	TWX,x
e3bb : 2607                   	bne   	POS
AS02 Assembler for M6802 [1.42].                                     Page   12
------------------------------------ tbug ------------------------------------

e3bd : c17f                   	cmpb 	#$7f
e3bf : 230a                   	bls   	OK
e3c1 : 7ee040           ERRR 	jmp  	LOAD19 		;out of range print ?
e3c4 : 4c               POS   	inca
e3c5 : 26fa                   	bne   	ERRR
e3c7 : c17f                   	cmpb 	#$7f
e3c9 : 23f6                   	bls   	ERRR
e3cb : e700             OK    	stab 	XHIX,x
e3cd : bde0bf               	jsr   	OUT2H  		;output offset to user
e3d0 : 7ee0e3               	jmp   	CONTRL 		;and return
                        ;
e3d3 : 47               TABLE 	db   	'G'     	;-jump table for command
e3d4 : e10f                   	dw   	GO
e3d6 : 4d                       db   	'M'     	;-memory inspect/modify
e3d7 : e085                   	dw   	CHANGE
e3d9 : 52                       db   	'R'     	;-print stack
e3da : e11f                   	dw   	PRINT
e3dc : 50                       db   	'P'     	;-punch in 's1' format
e3dd : e13d                   	dw   	PUNCH
e3df : 4c                       db   	'L'     	;-load 's1' format
e3e0 : e00a                   	dw   	LOAD
e3e2 : 56                       db   	'V'     	;-file with name
e3e3 : e33e                   	dw   	SAVE
e3e5 : 49                       db   	'I'     	;-input named file
e3e6 : e355                   	dw   	INFILE
e3e8 : 54                       db   	'T'     	;-calculate branch offset
e3e9 : e3a5                   	dw   	BCALC
e3eb : 4b                       db   	'K'     	;-output a block of memory
e3ec : e2f6                   	dw   	BLKTAB
e3ee : 59                       db   	'Y'     	;-copy block of memory
e3ef : e2cd                   	dw   	COPY
e3f1 : 4a                       db   	'J'     	;-jump to address
e3f2 : e1a1                   	dw   	JUMP
e3f4 : 55                       db   	'U'     	;-toggle caps lock ('U' used to
e3f5 : e107                   	dw   	TGLCAP
e3f7 : 75                       db   	'u'     	;-toggle caps lock ('U' used to
e3f8 : e107                   	dw   	TGLCAP
                        ;
                        ;Since this will never be placed in a 1K ROM, just kee
                        ;
e3fa : 5a               	db	'Z'
                        	if BASIC
e3fb : e61f             	dw	load_basic	;load BASIC from ROM and launch it	
                        	else
                        	dw	$c000		;Mod to replicate SWTBUG ROM command
                        	endif
e3fd : 00               	db	0
                        ;
e3fe : 0d0a0a00005442.. TBSTR   db      CR,LF,LF,0,0,"TBUG",EOT
                        ;
                        ;Old vectors went here - now moved to end of larger RO
                        ;
                        ;	dw	IRQ		;IRQ vector
                        ;	dw	SFE		;SWI vector
                        ;	dw	NMI		;NMI vector
                        ;	dw	START		;Reset vector
                        ;
                        ;###########################################
                        ;
                        ; LCD display driver
                        ;
                        
AS02 Assembler for M6802 [1.42].                                     Page   13
------------------------------------ tbug ------------------------------------

                        	include	"lcd/lcd_driver.asm"	;LCD driver code
                        		title "lcd_driver"
                        ;=====================================================
                        ;LCD driver for up to 4x40 LCD displays.
                        ;
                        ;NOTE: Current version only supports scrolling on 2x16
                        ;
                        ;Display is connected to the PIA as folows:
                        ;
                        ;PIA D0 - Enabled display active high
                        ;PIA D1 - Spare
                        ;PIA D2 - R/W
                        ;PIA D3 - E
                        ;PIA D4 - Display D4
                        ;PIA D5 - Display D5
                        ;PIA D6 - Display D6	 
                        ;PIA D7 - Display D7
                        ;
                        ;...display operates in 4-bit mode
                        ;
                        ;IMPORTANT: D0 needs to be high for the lcd display to
                        ;via lcd_outch.
                        ;
                        ;Code is designed to be included (using 'include') wit
                        ;Include all the equates and storage defined in the ne
                        ;
                        ;The use this driver, call the following:
                        ;
                        ;piab_init - initializes the PIA
                        ;lcd_init - initializes the LCD display
                        ;
                        ;Note: Driver uses a lot of async delays that assume a
                        ;
                        ;Use lcd_outch to display characters.
                        ;This routine processes CR, LF, BS and FF (clear scree
                        ;7F (RUBOUT) and all other ctrl characters are ignored
                        ;lcd_cursor can be used to set the cursor outside of l
                        ;
                        ;=====================================================
                        ;
                        ;All these equates must be included in the calling cod
                        ;
                        ;Equates
                        ;
                        ;PIABPR         equ     $8012
                        ;PIABCN		equ	$8013
                        ;
                        ; Common ASCII control codes
                        ;
                        ;EOT            equ     $04
                        ;BS             equ     $08
                        ;LF             equ     $0a
                        ;FF		equ	$0c
                        ;CR             equ     $0d
                        ;NULL		equ	$0
                        ;RUB		equ	$7f
                        ;
                        ;SPACE		equ	$20	;space character
                        ;
                        ;LCD constants
                        ;
                        ;LCDWIDTH	equ	16			;16x2 display
AS02 Assembler for M6802 [1.42].                                     Page   14
--------------------------------- lcd_driver ---------------------------------

                        ;LCDROWS	equ	2
                        ;LCDBUFSZ       equ     LCDWIDTH*LCDROWS        ;size 
                        ;
                        ; RAM area
                        ;
                        ;lcd_row		ds	1		;Current lcd row, 0 = top row	
                        ;lcd_col		ds	1		;Current lcd column, 0 = left-most col
                        ;lcd_buf		ds	LCDBUFSZ	;backing buffer for scrolling, e
                        ;lcd_tempx	ds	2			;tenp store for x reg, used to calcu
                        ;lcd_buf_addr	ds	2			;used to store buffer address val
                        ;lcd_charx	ds	3			;temp store for x reg - used to pres
                        ;
                        ;=====================================================
                        ;
                        ;####################################
                        ;Driver code
                        ;####################################
                        ;
                        ;Output character in a reg to display
                        ;
                        ;Ignore null, prcesses CR, LF, FF and BS correctly, ev
                        ;as a regular character. Display will scroll when last
                        ;a and x are retained, row and col values are modified
                        ;
e408 : 36               lcd_outch	psha
e409 : f68012           		ldab	PIABPR		;if D0 of PIA is low, skip outputing ch
e40c : c401             		andb	#$01
e40e : 275e             		beq	outretsb
e410 : 8100             		cmpa	#NULL		;if null, then do nothing
e412 : 275a             		beq	outretsb	
e414 : 817f             		cmpa	#RUB		;ignore rubout chars, so do nothing
e416 : 2756             		beq	outretsb
e418 : 810d             		cmpa	#CR		;is it a CR?
e41a : 2609             		bne	islf		;if not, branch
e41c : b6a08f           		ldaa	lcd_row		;for CR, set cursor to col 0
e41f : 5f               		clrb		
e420 : bde5fa           		jsr	lcd_cursor
e423 : 207b             		bra	outret
                        ;
e425 : 810a             islf		cmpa	#LF		;is it a LF?	
e427 : 261e             		bne	isbs		;if not, branch
e429 : b6a08f           		ldaa	lcd_row		;iscroll if needed
e42c : 8101             		cmpa	#LCDROWS-1	;check if we are on the last line
e42e : 260e             		bne	islf1		;is on last line, just scroll
e430 : b6a090           		ldaa	lcd_col		;get the current col
e433 : bde4a2           		jsr	lcd_scroll	;scroll display, a is preserved
e436 : 16               		tab			;set back cursor after scroll
e437 : 8601             		ldaa	#LCDROWS-1
e439 : bde5fa           		jsr	lcd_cursor
e43c : 2062             		bra	outret
                        ;
e43e : 4c               islf1		inca
e43f : f6a090           		ldab	lcd_col
e442 : bde5fa           		jsr	lcd_cursor
e445 : 2059             		bra	outret
                        ;
e447 : 8108             isbs		cmpa	#BS		;is it a BS?
e449 : 261c             		bne	isff		;if not, branch
e44b : f6a090           		ldab	lcd_col		;load current column
e44e : 2750             		beq	outret		;skip if already at zero column
e450 : 5a               		decb			;move back one space
e451 : b6a08f           		ldaa	lcd_row		;load row
AS02 Assembler for M6802 [1.42].                                     Page   15
--------------------------------- lcd_driver ---------------------------------

e454 : bde5fa           		jsr	lcd_cursor  	;point to previous character
e457 : 8620             		ldaa	#SPACE		;clear current character
e459 : 8dad             		jsr	lcd_outch
e45b : b6a08f           		ldaa	lcd_row		;load cursor position again
e45e : f6a090           		ldab	lcd_col
e461 : 5a               		decb			;move back one space
e462 : bde5fa           		jsr	lcd_cursor
e465 : 2039             		bra	outret
                        ;
e467 : 810c             isff		cmpa	#FF		;is it a form feed (clear screen)?
e469 : 2605             		bne	regchar
e46b : bde54f           		jsr	lcd_clear	;clear screen
e46e : 2030             outretsb	bra	outret		;label is so a short branch will 
                        ;
                        ;display a regular character. Wraps text and scrolls d
                        ;
e470 : 8120             regchar		cmpa	#SPACE		;skip for any control characters
e472 : 2d2c             		blt	outret
e474 : f6a090           		ldab	lcd_col		;test if at end of row
e477 : c110             		cmpb	#LCDWIDTH
e479 : 261f             		bne	regchar1	
e47b : f6a08f           		ldab	lcd_row		;now check if we are on the last row
e47e : c101             		cmpb	#LCDROWS-1
e480 : 270d             		beq	regchar2
e482 : 36               		psha			;if not on the last row, send CR,LF then disp
e483 : 860d             		ldaa	#CR
e485 : 8d81             		jsr	lcd_outch
e487 : 860a             		ldaa	#LF
e489 : bde408           		jsr	lcd_outch
e48c : 32               		pula
e48d : 200b             		bra	regchar1		
e48f : bde4a2           regchar2	jsr	lcd_scroll	;Last line reached, so scroll
e492 : 36               		psha
e493 : 8601             		ldaa	#LCDROWS-1	;set cursor to left most column
e495 : 5f               		clrb
e496 : bde5fa           		jsr	lcd_cursor
e499 : 32               		pula
e49a : bde58b           regchar1	jsr	lcd_char	;display character
e49d : 7ca090           		inc	lcd_col		;inc stored col count
e4a0 : 32               outret		pula
e4a1 : 39               		rts	
                        ;
                        ;
                        ;Scroll display up one line. Handles all formats of di
                        ;
                        ;Read a line from ther backing store and write to the 
                        ;then write a line of spaces to the last line.
                        ;Routine preserves a reg
                        ;NOTE: This is hardcode for 2 row displays - see comme
                        ;
                        ;Calculate backing store offset, store in lcd_tempx
                        ;
e4a2 : 36               lcd_scroll	psha
e4a3 : 5f               		clrb			;clear offset
e4a4 : 8601             		ldaa	#$1		;start at row 1 ***********TEMP, FIX FOR L
e4a6 : cb10             scrlcont	addb	#LCDWIDTH	
e4a8 : 4a               		deca
e4a9 : 26fb             		bne	scrlcont	;done with calculating offset	
                        ;		
e4ab : 1b               		aba			;store final offset in a
e4ac : cea091           		ldx	#lcd_buf	;load start of buffer address into x
e4af : ffa0b3           		stx	lcd_buf_addr	;store in memory so we can split in
AS02 Assembler for M6802 [1.42].                                     Page   16
--------------------------------- lcd_driver ---------------------------------

e4b2 : f6a0b4           		ldab	lcd_buf_addr+1	;load the lsb of the buffer addr
e4b5 : 1b               		aba			;add offset (which will always be < 4x40, max 
e4b6 : b7a0b2           		staa	lcd_tempx+1	;store lsb in temp mem address		
e4b9 : b6a0b3           		ldaa	lcd_buf_addr	;load the msb of the buffer addres
e4bc : 8900             		adca	#$0		;add the carry to the msb (this is a 8 + 1
e4be : b7a0b1           		staa	lcd_tempx	;store result in temp
e4c1 : fea0b1           		ldx	lcd_tempx	;load full 16 bit address value into x
                        ;	
e4c4 : 4f               		clra			;TEMP hard coded as row 0
e4c5 : 5f               		clrb
e4c6 : bde5fa           		jsr	lcd_cursor	;point to next row to be copied to
e4c9 : c610             		ldab	#LCDWIDTH	;load col counter with display width
e4cb : a600             scrlcp		ldaa	0,x		;load current character from backing
e4cd : 37               		pshb			;preserve b
e4ce : bde58b           		jsr	lcd_char	;write character	
e4d1 : 7ca090           		inc	lcd_col		;increament store col count
e4d4 : 33               		pulb			;get back b
e4d5 : 08               		inx			;point to next char in backing store
e4d6 : 5a               		decb	
e4d7 : 26f2             		bne	scrlcp		;done with copying row?
                        ;
                        ;Clear last line
                        ;
e4d9 : 8601             		ldaa	#LCDROWS-1
e4db : 5f               		clrb
e4dc : bde5fa           		jsr	lcd_cursor
e4df : c610             		ldab	#LCDWIDTH	
e4e1 : 8620             		ldaa	#SPACE
e4e3 : 37               scrlcll		pshb
e4e4 : bde58b           		jsr	lcd_char
e4e7 : 7ca090           		inc	lcd_col		;increment stored col count
e4ea : 33               		pulb
e4eb : 5a               		decb
e4ec : 26f5             		bne	scrlcll
                        ;
e4ee : 32               		pula
e4ef : 39               		rts
                        ;
                        ;Init PIAB as 8 bits of output lines
                        ;
e4f0 : 4f               piab_init	clra                    ;set up PIA
e4f1 : b78013           		staa    PIABCN
e4f4 : 86fe             		ldaa    #$fe		;set PIA ad D0 input, D1-D7 as output
e4f6 : b78012           		staa    PIABPR
e4f9 : 8604             		ldaa    #$04
e4fb : b78013           		staa    PIABCN
e4fe : 7f8012           		clr     PIABPR
e501 : 39               		rts
                        ;
                        ;Init lcd display
                        ;Lots off odd timing here. Also, we have to start by s
                        ;30h commands to resync the display into reading 8 bit
                        ;
e502 : ce04e2           lcd_init	ldx	#1250		;wait 100ms0
e505 : 8d6f             		bsr	ldelay
e507 : 8630             		ldaa	#$30		;start by sending three 30h commands	
e509 : 8d6f             		bsr 	lcd_cmd8
e50b : ce0271           		ldx	#625		;wait 5ms
e50e : 8d66             		bsr	ldelay
e510 : 8630             		ldaa	#$30
e512 : 8d66             		bsr 	lcd_cmd8
e514 : c611             		ldab	#17		;wait 100us
AS02 Assembler for M6802 [1.42].                                     Page   17
--------------------------------- lcd_driver ---------------------------------

e516 : 8d5a             		bsr	sdelay
e518 : 8630             		ldaa	#$30
e51a : 8d5e             		bsr 	lcd_cmd8
e51c : c611             		ldab	#17		;wait 100us	
e51e : 8d52             		bsr 	sdelay	
e520 : 8620             		ldaa	#$20		;Set to 4 bit mode
e522 : 8d56             		bsr 	lcd_cmd8
e524 : c611             		ldab	#17
e526 : 8d4a             		bsr	sdelay		;wait 100us
                        ;
                        ;Done with 8 bit access, now in 4 bit mode
                        ;
e528 : 8628             		ldaa	#$28		;set to 2 line 5x7 mode
e52a : bde5da           		jsr 	lcd_cmd
e52d : c609             		ldab	#9		;wait 50us
e52f : 8d41             		bsr	sdelay
e531 : 8608             		ldaa	#$08		;set display off
e533 : bde5da           		jsr 	lcd_cmd
e536 : c609             		ldab	#9		;wait 50us
e538 : 8d38             		bsr	sdelay
e53a : 8606              		ldaa	#$06		;no shift, cursor increases
e53c : bde5da           		jsr 	lcd_cmd
e53f : c609             		ldab	#9		;wait 50us
e541 : 8d2f             		bsr	sdelay
e543 : 860e             		ldaa	#$0e		;display on, cursor on
                        		;ldaa	#$0f		;display on, cursor on, cursor blink
e545 : bde5da           		jsr 	lcd_cmd
e548 : c609             		ldab	#9		;wait 50us
e54a : 8d26             		bsr	sdelay	
e54c : 8d01             		bsr 	lcd_clear		;clear display, home cursor
e54e : 39               		rts
                        ;
                        ;Clear screen, set cursor to home positiom
                        ;
e54f : ffa0b5           lcd_clear	stx	lcd_charx	;preserve x
e552 : 8601             		ldaa    #$01            ;clear screen
e554 : bde5da           		jsr     lcd_cmd
e557 : c6ff             		ldab    #$ff            ;delay for 1.53ms after clea
e559 : 8d17             		bsr     sdelay
e55b : 7fa08f           		clr	lcd_row		;reset local copy of cursor position
e55e : 7fa090           		clr	lcd_col
e561 : cea091           		ldx	#lcd_buf	;clear lcd backing buffer (write spaces
e564 : 8620             		ldaa	#SPACE		;load a space character
e566 : a700             clearlp		staa	0,x		;store in buffer	
e568 : 08               		inx
e569 : 8ca0b1           		cpx	#lcd_buf+LCDBUFSZ
e56c : 26f8             		bne	clearlp
e56e : fea0b5           		ldx	lcd_charx	;restore x
e571 : 39               		rts
                        ;
                        ;Short delay, delay value passed in b
                        ;Delay = (2+4)*b in microseconds
                        ;
e572 : 5a               sdelay		decb			;decrement b
e573 : 26fd             		bne sdelay
e575 : 39               		rts
                        ;
                        ;Long delay, delay valaue passed in x
                        ;Delay = (4+4)*x in microseconds
                        ;
e576 : 09               ldelay		dex
e577 : 26fd             		bne ldelay
AS02 Assembler for M6802 [1.42].                                     Page   18
--------------------------------- lcd_driver ---------------------------------

e579 : 39               		rts
                        ;
                        ;Send lcd command when display is in 8 bit mode
                        ;Note: this is only used during init
                        ;
e57a : 0f               lcd_cmd8	sei			;block interrupts since port maybe mult
e57b : 36               		psha			;Save a reg
e57c : 84f0             		anda	#$f0		;remove lower nibble since display is wir
e57e : 8a08             		oraa	#$08		;Set RS = 0, E = 1
e580 : b78012           		staa	PIABPR		;output PIA
                        					;placeholder - delay needed if hold time <10ns
e583 : 84f7             		anda	#$F7		;set RS = 0, E = 0
e585 : b78012           		staa	PIABPR		;leave date as-is but set E = 0
e588 : 32               		pula			;restore a reg
e589 : 0e               		cli
e58a : 39               		rts	
                        ;
                        ;Send character in a reg to LCD. A contains full 8 bit
                        ;Note: a reg is preserved, b is not, x is preserved
                        ;Also store character in backing buffer
                        ;
e58b : 0f               lcd_char	sei			;block interrupts since port maybe mult
e58c : 36               		psha                    ;Save a reg
e58d : ffa0b5           		stx	lcd_charx	;preserve x
e590 : 16               		tab			;send high nible first
e591 : c4f0             		andb	#$f0
e593 : ca0c             		orab	#$0c		;set RS = 1, E = 1
e595 : f78012           		stab	PIABPR		;send to PIA
                        					;placeholder - delay needed if hold time <10ns
e598 : c4f7             		andb	#$F7		;set E = 0, RS = 0
e59a : f78012           		stab	PIABPR		;send to PIA
e59d : 48                               lsla                    ;Shift data to
e59e : 48                               lsla
e59f : 48                               lsla
e5a0 : 48                               lsla
e5a1 : 8a0c             		oraa    #$0c            ;set RS = 1, E = 1			 
e5a3 : b78012           		staa	PIABPR          ;send lower nibble to PIA
                        					;placeholder - delay needed if hold time <10ns
e5a6 : 84f7             		anda    #$F7            ;set E = 0
e5a8 : b78012           		staa	PIABPR		;send to PIA
                        ;
                        ;Save character to backing store
                        ;
e5ab : 5f               		clrb
e5ac : b6a08f           		ldaa	lcd_row		;get current row
e5af : 2705             lcd_addrow	beq	lcd_addcol	;done with row adds
e5b1 : cb10             		addb	#LCDWIDTH			
e5b3 : 4a               		deca
e5b4 : 20f9             		bra	lcd_addrow
e5b6 : fba090           lcd_addcol	addb	lcd_col		;add the column offset	
e5b9 : 17               		tba			;store final offset in a
e5ba : cea091           		ldx	#lcd_buf	;load start of buffer address into x
e5bd : ffa0b3           		stx	lcd_buf_addr	;store in memory so we can split in
e5c0 : f6a0b4           		ldab	lcd_buf_addr+1	;load the lsb of the buffer addr
e5c3 : 1b               		aba			;add offset (which will always be < 4x40, max 
e5c4 : b7a0b2           		staa	lcd_tempx+1	;store lsb in temp mem address		
e5c7 : b6a0b3           		ldaa	lcd_buf_addr	;load the msb of the buffer addres
e5ca : 8900             		adca	#$0		;add the carry to the msb (this is a 8 + 1
e5cc : b7a0b1           		staa	lcd_tempx	;store result in temp
                        ;	
e5cf : 32               		pula			;restore character
e5d0 : fea0b1           		ldx	lcd_tempx	;store char in backing buffer based on
AS02 Assembler for M6802 [1.42].                                     Page   19
--------------------------------- lcd_driver ---------------------------------

e5d3 : a700             		staa	0,x
e5d5 : fea0b5           		ldx	lcd_charx	;restore x
e5d8 : 0e               		cli
e5d9 : 39               		rts
                        ;
                        ;Send command in a reg to LCD. A contains full 8 bit c
                        ;Note: a reg is preserved, b is not
                        ;
e5da : 0f               lcd_cmd		sei			;block interrupts since port maybe mult
e5db : 36               		psha                    ;Save a reg
e5dc : 16               		tab                     ;send high nible first
e5dd : c4f0             		andb    #$f0
e5df : ca08             		orab    #$08            ;set RS = 0, E = 1
e5e1 : f78012           		stab    PIABPR          ;send to PIA
                        					;placeholder - delay needed if hold time <10ns
e5e4 : c4f3             		andb    #$F3            ;set E = 0, RS = 0
e5e6 : f78012           		stab    PIABPR          ;send to PIA
e5e9 : 48               		lsla                    ;Shift data to upper nibble 
e5ea : 48               		lsla
e5eb : 48               		lsla
e5ec : 48               		lsla
e5ed : 8a08             		oraa    #$08            ;set RS = 0, E = 1          
e5ef : b78012           		staa    PIABPR          ;send lower nibble to PIA
                        					;placeholder - delay needed if hold time <10ns
e5f2 : 84f3             		anda    #$F3            ;set E = 0
e5f4 : b78012           		staa    PIABPR          ;send to PIA
e5f7 : 32               		pula
e5f8 : 0e               		cli
e5f9 : 39               		rts
                        ;
                        ;Set cursor position. Row in a, col in b, zero == lowe
                        ;The command to do this is 80h + (row * 40h (so line s
                        ;
e5fa : b7a08f           lcd_cursor	staa	lcd_row		;store local copies of row an
e5fd : f7a090           		stab	lcd_col	
e600 : 48               		lsla			;Multiply row number by 40h
e601 : 48               		lsla
e602 : 48               		lsla
e603 : 48               		lsla
e604 : 48               		lsla
e605 : 48               		lsla
e606 : 8a80             		ora	#$80		;add to command
e608 : 1b               		aba			;add col to address
e609 : 8dcf             		bsr	lcd_cmd		;send to display
e60b : 39               		rts
                        
                        		
                        		
                        
                        ;
                        ;
                        	if	BASIC
                        ;###########################################
                        ;
                        ; ROM copy code that copies a ROM image of TSC MicroBa
                        ; then runs it.
                        ; BASIC can't run directly from ROM because it has sel
                        ; code :(
                        ;
                        ;Start and end of ROM BASIC image - pushed right to th
                        ;page of memory
                        ;
AS02 Assembler for M6802 [1.42].                                     Page   20
--------------------------------- lcd_driver ---------------------------------

f3a3 =                  BASIC_START		equ	$f3a3
fff7 =                  BASIC_END		equ	$fff7
0100 =                  DEST_START              equ     $0100
0100 =                  BASIC_EXEC_START        equ     $0100
e60c : 0d0a4c6f616469.. basic_copymsg   db      CR,LF,"Loading BASIC...",EOT
1f00 =                  EXTERN			equ	$1f00		;TSC BASIC writes 'rts' to this lo
                        ;
                        ; Copy BASIC image to ROM, then run it
                        ;
e61f : cee60c           load_basic      ldx     #basic_copymsg		;display copy 
e622 : bde07e                           jsr     PDATA
e625 : ce0100                           ldx     #DEST_START             ;load 
e628 : ffa00f                           stx     TW
e62b : cef3a3                           ldx     #BASIC_START        	;load sou
e62e : ffa002                           stx     BEGA
e631 : cefff7                           ldx     #BASIC_END          	;load end
e634 : ffa004                           stx     ENDA
e637 : 8d0a                             bsr     memcopy                 ;copy 
e639 : ce1f00           		ldx	#EXTERN			;write 'rts' instruction to the EXTERN
e63c : 8639             		ldaa	#$39			;look at the TSC MicroBasic source code.
e63e : a700             		staa	0,x
e640 : 7e0100                           jmp     BASIC_EXEC_START        ;jump 
                        ;
                        ; memcopy routine. Destination start is in TW, source 
                        ;
e643 : fea002           memcopy         ldx     BEGA			;load source address
e646 : a600                             ldaa    0,x                     ;load 
e648 : fea00f           		ldx	TW			;load destination address
e64b : a700             		staa	0,x			;store byte
e64d : 08               		inx				;increment and store next destination address
e64e : ffa00f           		stx	TW
e651 : fea002           		ldx	BEGA			;reload current source address	
e654 : bca004           	        cpx	ENDA			;check if end reached?
e657 : 2706             		beq	done
e659 : 08               		inx				;else, increment source address and store it
e65a : ffa002           		stx	BEGA
e65d : 20e4             		bra	memcopy			;and keep going
e65f : 39               done            rts
                        
                        	endif
                        ;
                        ;###########################################
                        ;
                        ; BASIC image lives here, but is added in the build sc
                        ; Start = F3A3H
                        ; End = FFF7H
                        ;
                        ;###########################################
                        ;
                        ;Vectors - currently set for a 64K ROM, so lock this a
                        ;of the address range with its own org statement
                        
fff8 =                          org     $fff8
                        
fff8 : e000             	dw	IRQ		;IRQ vector
fffa : e113             	dw	SFE		;SWI vector
fffc : e005             	dw	NMI		;NMI vector
fffe : e0d0             	dw	START		;Reset vector
                        
                        ;
                        ;END
                        ;
AS02 Assembler for M6802 [1.42].                                     Page   21
--------------------------------- lcd_driver ---------------------------------

                        
                        
No errors in pass 2.
